#define kernelbase 0xFFFFFF8000100000ULL 
enum
{
	kOSSerializeDictionary          = 0x01000000U,
	kOSSerializeArray               = 0x02000000U,
	kOSSerializeSet                 = 0x03000000U,
	kOSSerializeNumber              = 0x04000000U,
	kOSSerializeSymbol              = 0x08000000U,
	kOSSerializeString              = 0x09000000U,
	kOSSerializeData                = 0x0a000000U,
	kOSSerializeBoolean             = 0x0b000000U,
	kOSSerializeObject              = 0x0c000000U,

	kOSSerializeTypeMask            = 0x7F000000U,
	kOSSerializeDataMask            = 0x00FFFFFFU,

	kOSSerializeEndCollection       = 0x80000000U,

	kOSSerializeMagic               = 0x000000d3U,
};
typedef uint64_t kptr_t;
typedef volatile struct{
	uint32_t iv_hash;
	uint32_t iv_sum;
	uint32_t iv_refs;
	uint32_t iv_table_size;
	uint32_t iv_inline_table[6];
	uint64_t padding0;
	uint64_t iv_table;
	uint64_t iv_port;
	uint64_t iv_hash_link_next;
	uint64_t iv_hash_link_prev;
} fake_ipc_voucher_t;

#define IO_BITS_ACTIVE	0x80000000
#define IOT_PORT	0
#define IKOT_TASK	2
#define IKOT_CLOCK	25
#define IKOT_IOKIT_CONNECT	29

#define WQT_QUEUE               0x2
#define _EVENT_MASK_BITS        ((sizeof(uint32_t) * 8) - 7)

#include <stdio.h>
#include <stddef.h>
#include <mach/mach.h>
typedef	struct slock {
	char	lock_data[80];
} usimple_lock_data_t, *usimple_lock_t;
typedef volatile struct{
	struct {
		natural_t io_bits;
		natural_t io_references;
		uint64_t io_lock_data;
	}ip_object;
	struct {
			struct {
				struct waitq {
					uint32_t /* flags */
						waitq_type:2,    /* only public field */
						waitq_fifo:1,    /* fifo wakeup policy? */
						waitq_prepost:1, /* waitq supports prepost? */
						waitq_irq:1,     /* waitq requires interrupts disabled */
						waitq_isvalid:1, /* waitq structure is valid */
						waitq_turnstile_or_port:1, /* waitq is embedded in a turnstile (if irq safe), or port (if not irq safe) */
						waitq_eventmask:_EVENT_MASK_BITS;
						/* the wait queue set (set-of-sets) to which this queue belongs */
					#if __arm64__
						uint32_t	waitq_interlock;	/* interlock */
					#else
						uint64_t	waitq_interlock;	/* interlock */
					#endif /* __arm64__ */

						uint64_t waitq_set_id;
						uint64_t waitq_prepost_id;
						
							struct{
								uint64_t next;
								uint64_t prev;
							}            waitq_queue;		/* queue of elements */
				}waitq;
				uint64_t	messages;
				uint32_t	seqno;
				uint32_t	receiver_name;
				uint16_t		msgcount;
				uint16_t		qlimit;
				uint32_t		pad;
			} port;
		union {
			uint64_t imq_klist;
			uintptr_t imq_inheritor;
		};
	} ip_messages;
	uint64_t receiver;
	uint64_t kobject;
	uint64_t ip_nsrequest;
	uint64_t ip_pdrequest;
	uint64_t ip_requests;
	uint64_t *premsg;
	uint64_t ip_context;
	natural_t ip_sprequests:1,	/* send-possible requests outstanding */
			  ip_spimportant:1,	/* ... at least one is importance donating */
			  ip_impdonation:1,	/* port supports importance donation */
			  ip_tempowner:1,	/* dont give donations to current receiver */
			  ip_guarded:1,         /* port guarded (use context value as guard) */
			  ip_strict_guard:1,	/* Strict guarding; Prevents user manipulation of context values directly */
			  ip_specialreply:1,	/* port is a special reply port */
			  ip_sync_link_state:3,	/* link the special reply port to destination port/ Workloop */
			  ip_impcount:22;	/* number of importance donations in nested queue */
	uint32_t ip_mscount;
	uint32_t ip_srights;
	uint32_t ip_sorights;
} ipc_port_t;

typedef struct
{
	struct {
		uint64_t data;
//		uint32_t reserved : 24,
//					type     :  8;
//		uint32_t pad;
		uint64_t unk;
	} lock; // mutex lock
	uint32_t ref_count;
	uint32_t active;
	uint32_t halting;
	uint32_t pad;
	uint64_t map;
} ktask_t;

union waitq_flags
{
	struct {
		uint32_t /* flags */
	waitq_type:2,    /* only public field */
	waitq_fifo:1,    /* fifo wakeup policy? */
	waitq_prepost:1, /* waitq supports prepost? */
	waitq_irq:1,     /* waitq requires interrupts disabled */
	waitq_isvalid:1, /* waitq structure is valid */
	waitq_turnstile_or_port:1, /* waitq is embedded in a turnstile (if irq safe), or port (if not irq safe) */
	waitq_eventmask:_EVENT_MASK_BITS;
	};
	uint32_t flags;
};

struct simple_msg {
	mach_msg_header_t hdr;
	char buf[0];
};
static inline uint32_t mach_port_waitq_flags() 
{
	union waitq_flags waitq_flags = {};
	waitq_flags.waitq_type              = WQT_QUEUE;
	waitq_flags.waitq_fifo              = 1;
	waitq_flags.waitq_prepost           = 0;
	waitq_flags.waitq_irq               = 0;
	waitq_flags.waitq_isvalid           = 1;
	waitq_flags.waitq_turnstile_or_port = 1;
	return waitq_flags.flags;
}
#define OFFSET_BSDTASK 0x380
#define OFFSET_PPID		0x60